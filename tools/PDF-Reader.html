<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PDF閱讀器">
    
    <title>PDF 閱讀器 (縮放增強版)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        reader: { bg: '#000000', panel: '#1c1c1e', text: '#f2f2f7', accent: '#0a84ff' }
                    },
                    spacing: { 'safe-top': 'env(safe-area-inset-top)', 'safe-bottom': 'env(safe-area-inset-bottom)' }
                }
            }
        }
    </script>

    <style>
        :root {
            --zoom-factor: 1;
        }

        body {
            -webkit-user-select: none; user-select: none;
            -webkit-tap-highlight-color: transparent;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overscroll-behavior: none;
            touch-action: pan-x pan-y;
            overflow: hidden;
        }
        
        .no-scrollbar::-webkit-scrollbar { display: none; }
        
        .glass-panel {
            background: rgba(28, 28, 30, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #scrollContainer {
            overflow-x: auto;
            overflow-y: hidden; /* 放大時允許 Canvas 內部捲動，但容器本身只做水平切換 */
            display: flex;
            flex-direction: row;
            width: 100vw;
            height: 100vh;
            align-items: center;
        }

        /* 只有在縮放為 1.0 時才開啟磁吸，避免放大時無法自由移動 */
        #scrollContainer.snap-active {
            scroll-snap-type: x mandatory;
        }

        .page-wrapper {
            /* 寬度根據縮放比例動態調整 */
            min-width: calc(100vw * var(--zoom-factor));
            width: calc(100vw * var(--zoom-factor));
            height: 100%;
            
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
            overflow: auto; /* 允許內容大於 Wrapper 時捲動 (雖然我們主要靠 Wrapper 變大) */
            
            /* GPU 優化 */
            transform: translateZ(0);
            will-change: transform, width; 
        }
        
        #scrollContainer.snap-active .page-wrapper {
            scroll-snap-align: center;
            scroll-snap-stop: always;
        }

        canvas {
            display: block;
            box-shadow: 0 4px 30px rgba(0,0,0,0.5);
            /* 讓 Canvas 在 Wrapper 內保持比例 */
            max-width: 98%; 
            max-height: 98%;
            object-fit: contain;
        }

        .skeleton {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            color: #48484a;
        }

        .btn-icon {
            display: flex; align-items: center; justify-content: center;
            border-radius: 9999px;
            transition: all 0.2s;
            color: #e5e5e7;
        }
        .btn-icon:active { background-color: rgba(255,255,255,0.15); transform: scale(0.92); }
    </style>
</head>
<body class="bg-black text-reader-text h-screen w-screen relative">

    <!-- 側邊導航欄 -->
    <div id="sidebarOverlay" onclick="toggleSidebar()" class="fixed inset-0 bg-black/60 z-[60] hidden opacity-0 transition-opacity duration-300 backdrop-blur-sm"></div>
    <div id="sidebar" class="fixed top-0 left-0 h-full w-72 bg-[#1c1c1e] z-[70] transform -translate-x-full transition-transform duration-300 shadow-2xl flex flex-col pt-safe-top pb-safe-bottom border-r border-white/10">
        <div class="p-5 border-b border-white/10 flex justify-between items-center">
            <span class="font-bold text-lg text-white/90">目錄</span>
            <button onclick="toggleSidebar()" class="btn-icon w-8 h-8 bg-white/5">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="outlineContainer" class="flex-1 overflow-y-auto p-3 space-y-1 text-sm text-gray-300 no-scrollbar">
            <div class="flex flex-col items-center justify-center h-40 text-gray-500 gap-2">
                <span>無目錄資訊</span>
            </div>
        </div>
    </div>

    <!-- 頂部標題列 -->
    <div id="topBar" class="fixed top-0 left-0 w-full glass-panel z-50 pt-safe-top transition-transform duration-300">
        <div class="flex justify-between items-center px-4 h-14 relative">
            <button onclick="toggleSidebar()" class="btn-icon w-10 h-10 -ml-2">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
            </button>

            <div class="absolute left-1/2 transform -translate-x-1/2 max-w-[60%] text-center">
                <h1 class="font-semibold text-sm truncate text-white/90 tracking-wide" id="bookTitle">PDF 閱讀器</h1>
            </div>

            <button onclick="openFilePicker()" class="btn-icon w-10 h-10 -mr-2 text-reader-accent">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
            </button>
        </div>
    </div>

    <!-- 主要閱讀區 -->
    <div id="scrollContainer" class="no-scrollbar scroll-smooth snap-active">
        <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-gray-500 z-0 w-screen">
            <p class="text-lg font-medium text-gray-400 mb-4">請載入文件</p>
            <button onclick="openFilePicker()" class="px-6 py-2 bg-reader-accent text-white rounded-full text-sm font-semibold shadow-lg">開啟 PDF</button>
        </div>
    </div>

    <!-- 底部控制列 -->
    <div id="bottomBar" class="fixed bottom-0 left-0 w-full z-50 transition-transform duration-300 pb-safe-bottom bg-black/80 backdrop-blur-md border-t border-white/10">
        <div class="flex flex-col px-4 pt-3 pb-2 gap-3">
            
            <!-- 縮放控制區 (新增) -->
            <div class="flex items-center justify-center gap-6">
                <button onclick="manualZoom(-0.25)" class="btn-icon w-8 h-8 bg-white/10 active:bg-white/20">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path></svg>
                </button>
                
                <button onclick="resetZoom()" class="px-3 py-1 bg-white/5 rounded-full text-xs font-mono text-gray-300 border border-white/10 active:bg-white/20" id="zoomDisplay">
                    適應螢幕
                </button>
                
                <button onclick="manualZoom(0.25)" class="btn-icon w-8 h-8 bg-white/10 active:bg-white/20">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                </button>
            </div>

            <!-- 翻頁與進度 -->
            <div class="flex items-center justify-between gap-4 h-10">
                <button onclick="jumpRelative(-1)" class="btn-icon w-10 h-10">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                </button>

                <div class="flex-1 flex flex-col items-center">
                    <span id="pageInfo" class="text-[10px] font-mono text-gray-400 mb-1">0 / 0</span>
                    <input type="range" id="pageSlider" min="1" max="1" value="1" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-blue-500" oninput="onSliderInput(this.value)" onchange="onSliderChange(this.value)">
                </div>

                <button onclick="jumpRelative(1)" class="btn-icon w-10 h-10">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <!-- 狀態 Toast -->
    <div id="statusToast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black/70 backdrop-blur px-5 py-3 rounded-xl text-white font-medium opacity-0 pointer-events-none transition-opacity duration-300 z-[90]">
        100%
    </div>

    <input type="file" id="fileInput" accept="application/pdf" class="hidden">
    <div id="loader" class="fixed inset-0 flex items-center justify-center bg-black/50 backdrop-blur-sm z-[80] hidden">
        <div class="w-10 h-10 border-2 border-white/20 border-t-white rounded-full animate-spin"></div>
    </div>

    <script>
        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').catch(err => console.log('SW fail', err));
        }

        let pdfDoc = null;
        let totalPages = 0;
        let currentPage = 1;
        let currentZoom = 1.0; // 1.0 = Fit Screen
        let pageStates = {}; 
        let observer = null;
        let isUserScrolling = false;
        let scrollTimeout = null;
        let uiVisible = true;
        let redrawTimeout = null;
        let toastTimeout = null;
        
        // 觸控手勢變數
        let initialPinchDistance = null;
        let initialPinchZoom = null;

        window.addEventListener('load', async () => {
            const savedPdf = await localforage.getItem('cached_pdf_data');
            const savedName = await localforage.getItem('cached_pdf_name');
            const savedPage = await localforage.getItem('cached_current_page');
            const savedZoom = await localforage.getItem('cached_zoom_val');

            if (savedZoom) {
                currentZoom = parseFloat(savedZoom);
                updateZoomUI();
            }

            if (savedPdf) {
                document.getElementById('bookTitle').innerText = savedName || '文件';
                loadPdfDocument(savedPdf, savedPage || 1);
            }
            
            document.getElementById('scrollContainer').addEventListener('click', (e) => {
                if (!isUserScrolling && !initialPinchDistance) toggleUI();
            });

            document.getElementById('scrollContainer').addEventListener('scroll', handleScroll);
            setupTouchGestures();
            
            // 監聽旋轉以重置版面
            window.addEventListener('resize', () => {
                jumpToPage(currentPage, false);
            });
        });

        function toggleUI() {
            uiVisible = !uiVisible;
            const top = document.getElementById('topBar');
            const bottom = document.getElementById('bottomBar');
            if (uiVisible) {
                top.classList.remove('-translate-y-full');
                bottom.classList.remove('translate-y-full');
            } else {
                top.classList.add('-translate-y-full');
                bottom.classList.add('translate-y-full');
            }
        }

        function openFilePicker() { document.getElementById('fileInput').click(); }

        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('loader').classList.remove('hidden');
            document.getElementById('bookTitle').innerText = file.name;

            const reader = new FileReader();
            reader.onload = async function() {
                const arrayBuffer = this.result;
                try {
                    await localforage.clear();
                    await localforage.setItem('cached_pdf_data', arrayBuffer);
                    await localforage.setItem('cached_pdf_name', file.name);
                } catch (err) {}
                loadPdfDocument(arrayBuffer, 1);
            };
            reader.readAsArrayBuffer(file);
        });

        async function loadPdfDocument(data, initialPage = 1) {
            try {
                const loadingTask = pdfjsLib.getDocument(data);
                pdfDoc = await loadingTask.promise;
                totalPages = pdfDoc.numPages;

                document.getElementById('emptyState').classList.add('hidden');
                document.getElementById('loader').classList.add('hidden');
                
                const slider = document.getElementById('pageSlider');
                slider.max = totalPages;
                slider.value = initialPage;
                updatePageInfo(initialPage);

                const container = document.getElementById('scrollContainer');
                const emptyState = document.getElementById('emptyState');
                container.innerHTML = '';
                container.appendChild(emptyState);
                
                pageStates = {}; 
                
                const fragment = document.createDocumentFragment();
                for (let i = 1; i <= totalPages; i++) {
                    const wrapper = document.createElement('div');
                    wrapper.id = `page-wrapper-${i}`;
                    wrapper.className = 'page-wrapper'; 
                    wrapper.dataset.pageNum = i;
                    
                    wrapper.innerHTML = `
                        <div class="skeleton">
                            <span class="text-xs text-gray-600 font-mono tracking-widest">${i}</span>
                        </div>
                    `;
                    fragment.appendChild(wrapper);
                }
                container.appendChild(fragment);

                setupIntersectionObserver();
                loadOutline();
                updateZoomUI();

                setTimeout(() => {
                    jumpToPage(parseInt(initialPage), false);
                }, 100);

            } catch (err) {
                alert('載入錯誤: ' + err.message);
                document.getElementById('loader').classList.add('hidden');
            }
        }

        function handleScroll() {
            isUserScrolling = true;
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                isUserScrolling = false;
                
                const container = document.getElementById('scrollContainer');
                // 使用 getBoundingClientRect 獲取當前實際每一頁的寬度 (含縮放)
                // 這裡假設每一頁寬度一致，取第一頁或直接算 CSS
                const pageWidth = window.innerWidth * currentZoom;
                
                const newPage = Math.round(container.scrollLeft / pageWidth) + 1;
                
                if (newPage !== currentPage && newPage >= 1 && newPage <= totalPages) {
                    currentPage = newPage;
                    updatePageInfo(currentPage);
                    localforage.setItem('cached_current_page', currentPage);
                }
            }, 100);
        }

        // --- 縮放邏輯 ---

        function manualZoom(delta) {
            setZoom(currentZoom + delta);
        }

        function resetZoom() {
            setZoom(1.0);
        }

        function setZoom(newZoom) {
            // 限制縮放範圍：0.5x ~ 3.0x
            const clamped = Math.max(0.5, Math.min(3.0, newZoom));
            if (Math.abs(clamped - currentZoom) < 0.01) return;

            const oldZoom = currentZoom;
            currentZoom = clamped;
            
            updateZoomUI();
            localforage.setItem('cached_zoom_val', currentZoom);

            showStatusToast(`${Math.round(currentZoom * 100)}%`);

            // 1. 更新 CSS 變數，頁面容器寬度會立即改變
            document.documentElement.style.setProperty('--zoom-factor', currentZoom);

            // 2. 切換磁吸狀態：只有 1.0 (Fit Screen) 時開啟磁吸
            const container = document.getElementById('scrollContainer');
            if (Math.abs(currentZoom - 1.0) < 0.05) {
                container.classList.add('snap-active');
            } else {
                container.classList.remove('snap-active');
            }

            // 3. 修正捲動位置：因為寬度變了，要跳回原本那頁
            // 計算：原本位置比例 * 新總寬度
            // 更簡單：(currentPage - 1) * 單頁新寬度
            const targetLeft = (currentPage - 1) * (window.innerWidth * currentZoom);
            container.scrollLeft = targetLeft;

            // 4. 延遲重繪 Canvas 以獲得高解析度
            clearTimeout(redrawTimeout);
            redrawTimeout = setTimeout(() => {
                // 找出當前可見頁面並強制重繪
                document.querySelectorAll('.page-wrapper').forEach(wrapper => {
                    const rect = wrapper.getBoundingClientRect();
                    if (rect.right > 0 && rect.left < window.innerWidth) {
                        const num = parseInt(wrapper.dataset.pageNum);
                        unloadPage(num); // 先卸載舊解析度
                        renderPage(num); // 用新縮放率重繪
                    }
                });
            }, 300);
        }

        function updateZoomUI() {
            const display = document.getElementById('zoomDisplay');
            if (Math.abs(currentZoom - 1.0) < 0.05) {
                display.innerText = "適應螢幕";
                display.classList.add('bg-white/20');
            } else {
                display.innerText = `${Math.round(currentZoom * 100)}%`;
                display.classList.remove('bg-white/20');
            }
        }

        function showStatusToast(text) {
            const toast = document.getElementById('statusToast');
            toast.innerText = text;
            toast.classList.remove('opacity-0');
            clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                toast.classList.add('opacity-0');
            }, 1000);
        }

        // --- 觸控縮放 (Pinch) ---
        function setupTouchGestures() {
            const container = document.getElementById('scrollContainer');
            
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialPinchDistance = getTouchDistance(e.touches);
                    initialPinchZoom = currentZoom;
                    e.preventDefault(); // 防止瀏覽器原生縮放
                }
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && initialPinchDistance) {
                    e.preventDefault();
                    const dist = getTouchDistance(e.touches);
                    const ratio = dist / initialPinchDistance;
                    // 即時更新 (不重繪 Canvas，只改 CSS)
                    const tempZoom = Math.max(0.5, Math.min(3.0, initialPinchZoom * ratio));
                    document.documentElement.style.setProperty('--zoom-factor', tempZoom);
                    // 暫時關閉磁吸
                    container.classList.remove('snap-active');
                }
            }, { passive: false });

            container.addEventListener('touchend', (e) => {
                if (e.touches.length < 2 && initialPinchDistance) {
                    // 手指放開，正式設定縮放值並重繪
                    const computedStyle = getComputedStyle(document.documentElement).getPropertyValue('--zoom-factor');
                    const finalZoom = parseFloat(computedStyle);
                    initialPinchDistance = null;
                    setZoom(finalZoom);
                }
            });
        }

        function getTouchDistance(touches) {
            return Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
        }

        // --- 頁面跳轉 ---
        
        function updatePageInfo(num) {
            document.getElementById('pageInfo').innerText = `${num} / ${totalPages}`;
            document.getElementById('pageSlider').value = num;
        }

        function onSliderInput(val) {
            document.getElementById('pageInfo').innerText = `${val} / ${totalPages}`;
        }

        function onSliderChange(val) {
            jumpToPage(parseInt(val));
        }

        function jumpRelative(delta) {
            jumpToPage(currentPage + delta);
        }

        function jumpToPage(num, smooth = true) {
            if (num < 1 || num > totalPages) return;
            const container = document.getElementById('scrollContainer');
            
            // 計算：頁碼 * 當前縮放後的頁寬
            const pageWidth = window.innerWidth * currentZoom;
            const targetLeft = (num - 1) * pageWidth;
            
            container.scrollTo({
                left: targetLeft,
                behavior: smooth ? 'smooth' : 'auto'
            });
            
            currentPage = num;
            updatePageInfo(num);
        }

        // --- 渲染核心 ---

        function setupIntersectionObserver() {
            const options = {
                root: document.getElementById('scrollContainer'),
                rootMargin: '100% 0px', // 水平預載
                threshold: 0.1
            };

            if (observer) observer.disconnect();
            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const pageNum = parseInt(entry.target.dataset.pageNum);
                    if (entry.isIntersecting) {
                        renderPage(pageNum);
                    } else {
                        unloadPage(pageNum);
                    }
                });
            }, options);

            document.querySelectorAll('.page-wrapper').forEach(el => observer.observe(el));
        }

        function unloadPage(num) {
            const state = pageStates[num];
            if (!state) return;
            if (state.rendering && state.task) state.task.cancel();

            if (state.rendered || state.rendering) {
                const wrapper = document.getElementById(`page-wrapper-${num}`);
                if (wrapper) {
                    const canvas = wrapper.querySelector('canvas');
                    if (canvas) {
                        canvas.width = 1; canvas.height = 1; canvas.remove();
                    }
                    if (!wrapper.querySelector('.skeleton')) {
                        wrapper.innerHTML = `<div class="skeleton"><span class="text-xs text-gray-600 font-mono tracking-widest">${num}</span></div>`;
                    }
                }
                delete pageStates[num];
            }
        }

        async function renderPage(num) {
            if (pageStates[num] && (pageStates[num].rendering || pageStates[num].rendered)) return;
            pageStates[num] = { rendering: true, rendered: false };

            try {
                const page = await pdfDoc.getPage(num);
                const wrapper = document.getElementById(`page-wrapper-${num}`);
                if (!wrapper) return;

                const viewportRaw = page.getViewport({ scale: 1 });
                
                // 1. 計算適合 Wrapper 的比例 (Contain)
                // Wrapper 大小已經由 CSS (currentZoom) 決定了
                const wrapperW = wrapper.clientWidth;
                const wrapperH = wrapper.clientHeight;
                
                const scaleW = wrapperW / viewportRaw.width;
                const scaleH = wrapperH / viewportRaw.height;
                const fitScale = Math.min(scaleW, scaleH);

                // 2. 計算渲染畫質 (Output Scale)
                // iPad Air 2 優化：
                // 如果是 Fit Screen (Zoom=1)，DPR=2，渲染 2x 清晰度。
                // 如果 Zoom=3，DPR=2，理論上要渲染 6x，會當機。
                // 所以我們設定 cap (上限)，最大渲染比例不超過 2.0 (相對於原始 PDF 尺寸)
                // 這保證放大時文字會變清晰，但不會無限增加導致記憶體爆掉
                let deviceDPR = window.devicePixelRatio || 1;
                let desiredScale = fitScale * deviceDPR;
                
                // 記憶體安全鎖：強制限制最大渲染倍率
                // 這樣就算放大到 300%，Canvas 也不會大到吃光 2GB RAM
                let finalScale = Math.min(desiredScale, 2.0); 

                const viewport = page.getViewport({ scale: finalScale });

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { alpha: false });

                canvas.width = viewport.width;
                canvas.height = viewport.height;

                // 3. 透過 CSS 讓 Canvas 填滿 Wrapper (保持比例)
                // 因為我們 render 的像素可能比實際顯示少 (為了效能)，所以要用 CSS 拉伸
                canvas.style.width = "auto";
                canvas.style.height = "auto";
                canvas.style.maxWidth = "100%";
                canvas.style.maxHeight = "100%";

                const renderContext = { canvasContext: ctx, viewport: viewport };
                const renderTask = page.render(renderContext);
                pageStates[num].task = renderTask;

                await renderTask.promise;

                if (document.getElementById(`page-wrapper-${num}`)) {
                    wrapper.innerHTML = ''; 
                    wrapper.appendChild(canvas);
                }
                pageStates[num] = { rendering: false, rendered: true };

            } catch (err) {
                delete pageStates[num];
            }
        }

        async function loadOutline() {
            // (與前版相同，略為精簡以節省篇幅)
            const container = document.getElementById('outlineContainer');
            container.innerHTML = '';
            try {
                const outline = await pdfDoc.getOutline();
                if (!outline || outline.length === 0) {
                    container.innerHTML = `<div class="flex flex-col items-center justify-center h-40 text-gray-500 gap-2"><span>無目錄</span></div>`;
                    return;
                }
                async function buildTree(items) {
                    const ul = document.createElement('ul');
                    ul.className = 'space-y-1 ml-2';
                    for (const item of items) {
                        const li = document.createElement('li');
                        const btn = document.createElement('button');
                        btn.className = 'text-left w-full hover:bg-white/5 px-3 py-3 rounded-md truncate transition block text-gray-300 hover:text-white text-base border-b border-white/5';
                        btn.innerText = item.title;
                        btn.onclick = async () => {
                            if (item.dest) {
                                let dest = item.dest;
                                if (typeof dest === 'string') dest = await pdfDoc.getDestination(dest);
                                if (dest) {
                                    const ref = dest[0];
                                    const pageIndex = await pdfDoc.getPageIndex(ref);
                                    jumpToPage(pageIndex + 1, false); 
                                    toggleSidebar();
                                }
                            }
                        };
                        li.appendChild(btn);
                        ul.appendChild(li);
                        if (item.items && item.items.length > 0) {
                            li.appendChild(await buildTree(item.items));
                        }
                    }
                    return ul;
                }
                container.appendChild(await buildTree(outline));
            } catch (err) {}
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            if (sidebar.classList.contains('-translate-x-full')) {
                sidebar.classList.remove('-translate-x-full');
                overlay.classList.remove('hidden');
                setTimeout(() => overlay.classList.remove('opacity-0'), 10);
            } else {
                sidebar.classList.add('-translate-x-full');
                overlay.classList.add('opacity-0');
                setTimeout(() => overlay.classList.add('hidden'), 300);
            }
        }
    </script>
</body>
</html>


